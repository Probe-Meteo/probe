<?php
require_once 'toolbox.php';
class dir
{// folder scanner. Allow to apply filters

/*# -------- CLASS PROPERTIES -------- */
	PRIVATE $PATH = './'; // working path
  PRIVATE $DIRLIST = array();
//   PRIVATE $PATTERNS = array(
//     'backup_linux' => '/~$/' // Linux backup file
//   );
  PUBLIC $FILTERS = array( // preset filters. Boolean value
    'hidden'    => FALSE,
    'directory' => FALSE,
    'link'      => FALSE,
    'filesize'  => FALSE,
    'patterns'  => array(), // list of simple patterns
    'regexp'    => FALSE // regexp patterns
  );


/*# -------- PATH -------- */
  function set_path($path)
  {// set working directory. default is current directory
    $this->PATH = $path;
  }

  function get_path()
  {// get working directory
    return $this->PATH;
  }


/*# -------- SCANNING -------- */
  function dirlist()
  {// default scan = everything.
    $this->DIRLIST = scandir($this->PATH); // affect as properties to allow complex filtering
  }

  function get_dirlist()
  {// get the (filtered or not) list
    return $this->DIRLIST;
  }


/*# -------- FILTERS -------- */
//   function set_filters($filters)
//   {
//     $this->FILTERS = $filters;
//   }

  function get_filters()
  {// give the current list of filters
    return $this->FILTERS;
  }

  function filter_dirlist()
  {// apply filters by drop item that match (filter[x] AND type)
    foreach ($this->DIRLIST as $key => $item)
    {
      if ( ($this->FILTERS['hidden']==TRUE      and $this->match_hidden($item)==TRUE)
        or ($this->FILTERS['directory']==TRUE   and $this->match_directory($item)==TRUE)
        or ($this->FILTERS['link']==TRUE        and $this->match_link($item)==TRUE)
        or ($this->FILTERS['filesize']>0        and $this->match_filesize($item)==TRUE)
        or (count($this->FILTERS['patterns'])>0 and $this->match_pattern($item, true)==TRUE)
        or ($this->FILTERS['regexp']==TRUE      and $this->match_pattern($item)==TRUE) )
      {
        //printf('Drop: %s<br/>', $item);
        unset($this->DIRLIST[$key]);
        continue;
      }
    }
  }

/*## -------- FILTERS MATCH -------- */
// tell if 'item' match the filter. Allow to do actions depending on mymetype
  function match_hidden($item)
  {// is an hidden file ?
    $result = FALSE;
    if (preg_match('#^\.#', $item)>0)
    {
      $result = TRUE;
    }
    return $result;
  }
  function match_directory($item)
  {// is a directory ?
    $result = FALSE;
    if (is_dir($item)==TRUE)
    {
      $result = TRUE;
    }
    return $result;
  }
  function match_link($item)
  {// is a sym/link ?
    $result = FALSE;
    if (is_link($item)==TRUE)
    {
      $result = TRUE;
    }
    return $result;
  }

  function match_filesize($item)
  {// is smaller than FILTERS['filesize'] ?
    $result = FALSE;
    $fz = $this->get_filesize($item, FALSE);

    if ($fz <= $this->FILTERS['filesize'])
    {
      $result = TRUE;
    }
    return $result;
  }

  function match_pattern($item, $list = FALSE)
  {// match pattern ? If 'list' is given try to match 'item' against all (basic) pattern of 'list'.
    $result = FALSE;

    if ($list==FALSE)
    {// use extended regexp (http://en.wikipedia.org/wiki/Regular_expression#POSIX_Extended_Regular_Expressions)
      //printf("%s | %s (%s)<br/>", $item, $this->FILTERS['regexp'], dump($list));
      if (preg_match($this->FILTERS['regexp'], $item)==TRUE)
      {
        $result = TRUE;
      }
    } else
    {// use basic regexp (http://en.wikipedia.org/wiki/Regular_expression#POSIX_Basic_Regular_Expressions)
      foreach ($this->FILTERS['patterns'] as $pattern)
      {
        if (ereg($pattern, $item)==TRUE)
        {
          $result = TRUE;
          break;
        }
      }
    }
    //printf("&emsp;-> %s result: %b<br/>", $item, $result);
    return $result;
  }

/*# -------- META FUNCTIONS -------- */
  function get_filesize($item, $human = TRUE)
  {// item filesize. Could be formated to improve human readability
    $result = filesize($item);

    if ($human==TRUE)
    {
      $result = $this->format_filesize($result);
    }
    return $result;
  }

  function format_filesize($bytes, $precision = 2)
  {// human readable filesize. See http://fr3.php.net/manual/fr/function.filesize.php#91477
    $units = array('B', 'KB', 'MB', 'GB', 'TB');

    $bytes = max($bytes, 0);
    $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
    $pow = min($pow, count($units) - 1);

    $bytes /= pow(1024, $pow);

    return round($bytes, $precision) . ' ' . $units[$pow];
  }

/*# -------- CONSTRUCTOR -------- */
	function __construct()
	{
	}
}

?>